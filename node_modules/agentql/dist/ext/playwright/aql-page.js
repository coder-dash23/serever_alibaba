"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrap = wrap;
const api_constants_1 = require("../../core/api-constants");
const errors_1 = require("../../core/errors");
const logger_1 = require("../../core/logger");
const parser_1 = require("../../core/syntax/parser");
const aql_locator_1 = require("./aql-locator");
const aql_response_proxy_1 = require("./aql-response-proxy");
const driver_1 = require("./driver");
const driver_constants_1 = require("./driver-constants");
const page_monitor_1 = require("./page-monitor");
const utils_1 = require("./utils");
/**
 * Casts a Playwright `Page` object to an AgentQL `Page` type to get access to the AgentQL's querying API.
 *
 * @param {Page} page - The Playwright Page object to be wrapped.
 * @returns {PageExt} The wrapped Page object with AgentQL extensions.
 */
function wrap(page) {
    return __awaiter(this, void 0, void 0, function* () {
        const originalGoto = page.goto;
        let monitor = null;
        if (monitor === null) {
            monitor = new page_monitor_1.PageActivityMonitor(page);
            monitor.start();
        }
        yield monitor.monitorDomChange();
        return Object.assign(page, {
            goto(url, options) {
                return __awaiter(this, void 0, void 0, function* () {
                    logger_1.logger.debug(`Navigating to URL: ${url} with options: ${JSON.stringify(options)}...`);
                    if (!options) {
                        options = {};
                    }
                    if (!options.waitUntil) {
                        options.waitUntil = 'domcontentloaded';
                    }
                    const result = yield originalGoto.call(page, url, options);
                    monitor.monitorDomChange();
                    logger_1.logger.debug(`Navigation to URL: ${url} completed.`);
                    return result;
                });
            },
            getByPrompt(prompt_1) {
                return __awaiter(this, arguments, void 0, function* (prompt, timeout = driver_constants_1.DEFAULT_QUERY_ELEMENTS_TIMEOUT_SECONDS * 1000, waitForNetworkIdle = driver_constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = driver_constants_1.DEFAULT_INCLUDE_HIDDEN_ELEMENTS, mode = api_constants_1.DEFAULT_RESPONSE_MODE) {
                    logger_1.logger.debug(`Getting element by prompt: ${prompt}...`);
                    yield this.waitForPageReadyState(waitForNetworkIdle);
                    const element = yield (0, driver_1.pwGetByPrompt)(page, prompt, timeout, includeHidden, mode);
                    if (!element) {
                        logger_1.logger.debug(`No element found for prompt: ${prompt}.`);
                        return null;
                    }
                    const locator = yield (0, driver_1.pwLocateInteractiveElement)(page, element);
                    if (!locator) {
                        logger_1.logger.debug(`No locator found for element with prompt: ${prompt}.`);
                        return null;
                    }
                    logger_1.logger.debug(`Element found for prompt: ${prompt}.`);
                    return (0, aql_locator_1.wrapLocator)(locator, element);
                });
            },
            queryElements(query_1) {
                return __awaiter(this, arguments, void 0, function* (query, timeout = driver_constants_1.DEFAULT_QUERY_ELEMENTS_TIMEOUT_SECONDS * 1000, waitForNetworkIdle = driver_constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = driver_constants_1.DEFAULT_INCLUDE_HIDDEN_ELEMENTS, mode = api_constants_1.DEFAULT_RESPONSE_MODE) {
                    logger_1.logger.debug(`Querying elements with query: ${(0, logger_1.minifyQuery)(query)}...`);
                    const queryNode = new parser_1.QueryParser(query).parse();
                    yield this.waitForPageReadyState(waitForNetworkIdle);
                    const response = yield (0, driver_1.pwQueryElements)(page, query, timeout, includeHidden, mode);
                    const locators = yield (0, aql_locator_1.generateResponseWithLocatorExt)(page, response, queryNode);
                    logger_1.logger.debug(`Query for elements completed: ${(0, logger_1.minifyQuery)(query)}.`);
                    return new aql_response_proxy_1.AQLResponseProxy(locators, queryNode);
                });
            },
            queryData(query_1) {
                return __awaiter(this, arguments, void 0, function* (query, timeout = driver_constants_1.DEFAULT_QUERY_DATA_TIMEOUT_SECONDS * 1000, waitForNetworkIdle = driver_constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE, includeHidden = driver_constants_1.DEFAULT_INCLUDE_HIDDEN_DATA, mode = api_constants_1.DEFAULT_RESPONSE_MODE) {
                    logger_1.logger.debug(`Querying data with query: ${(0, logger_1.minifyQuery)(query)}...`);
                    new parser_1.QueryParser(query).parse();
                    yield this.waitForPageReadyState(waitForNetworkIdle);
                    return yield (0, driver_1.pwQueryData)(page, query, timeout, includeHidden, mode);
                });
            },
            waitForPageReadyState() {
                return __awaiter(this, arguments, void 0, function* (waitForNetworkIdle = driver_constants_1.DEFAULT_WAIT_FOR_NETWORK_IDLE) {
                    logger_1.logger.debug(`Waiting for page to reach 'Page Ready' state...`);
                    if (!waitForNetworkIdle) {
                        // If we don't need to wait for network idle, we can return early and not start the monitor.
                        // We have overridden the page.goto method to wait for "domcontentloaded" already.
                        logger_1.logger.debug('Page ready: "load" event catched.');
                        return;
                    }
                    if (monitor === null) {
                        throw new errors_1.PageMonitorNotInitializedError();
                    }
                    yield (0, utils_1.determineLoadState)(page, monitor);
                    monitor.reset();
                });
            },
        });
    });
}
